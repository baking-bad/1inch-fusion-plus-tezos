// Source: https://github.com/madfish-solutions/yupana-protocol-core/blob/07389aa7b350188e3c7a9e742a8c5276fc4a05b8/contracts/main/fa2.ligo
#include "types.jsligo"

const not_operator: string = "FA2_NOT_OPERATOR";
const undefined: string = "FA2_TOKEN_UNDEFINED";
const not_owner: string = "FA2_NOT_OWNER";
const low_balance: string = "FA2_INSUFFICIENT_BALANCE";
const not_admin: string = "FA2_NOT_ADMIN";

// @inline
const assert_with_error = (condition: bool, error: string): unit => 
    !condition ? failwith(error) : unit;

// @inline
const no_operations: list<operation> = list([]);

// @inline
const get_nat_or_fail = (value: int, error: string): nat =>
    match(is_nat(value)) {
        when(Some(natural)): natural;
        when(None): (failwith(error) as nat)
    };

/* Helper function to get account */
const get_account = (user: address, s: storage_t): account_t =>
    match(Big_map.find_opt(user, s.account_info)) {
        when(None): ({
            balances: (Map.empty as map<token_id_t, nat>),
            updated: Tezos.get_now(),
            permits: (Set.empty as set<address>)
        });
        when(Some(v)): v
    };

/* Helper function to get token info */
const get_token_info = (token_id: token_id_t, s: storage_t): token_info_t =>
    match(Big_map.find_opt(token_id, s.token_info)) {
        when(None): ({total_supply: 0 as nat});
        when(Some(v)): v
    };

/* Helper function to get account balance by token */
const get_balance_by_token = (user: account_t, token_id: token_id_t): nat =>
    match(Map.find_opt(token_id, user.balances)) {
        when(None): 0 as nat;
        when(Some(v)): v
    };

/* Perform transfers */
const iterate_transfer = ([s_, params]: [storage_t, transfer_param_t]): storage_t => {
    let s = s_;
    /* Perform single transfer */
    const make_transfer = ([s_, transfer_dst]: [storage_t, transfer_destination_t]): storage_t => {
        let s = s_;
        /* Create or get source account */
        let src_account: account_t = get_account(params.from_, s);

        /* Check permissions */
        assert_with_error(params.from_ == Tezos.get_sender() || Set.mem(Tezos.get_sender(), src_account.permits), not_operator);

        /* Token id check */
        assert_with_error(transfer_dst.token_id < s.last_token_id, undefined);

        /* Get source balance */
        const src_balance: nat = get_balance_by_token(src_account, transfer_dst.token_id);

        /* Balance check */
        if (src_balance - transfer_dst.amount < 0) { 
            return failwith(["Not enough balance", transfer_dst.token_id, src_balance, transfer_dst.amount]);
        };

        /* Update source balance */
        src_account = ({
            ...src_account, 
            balances: Map.update(
                transfer_dst.token_id,
                Some(get_nat_or_fail(src_balance - transfer_dst.amount, low_balance)),
                src_account.balances
            )
        });

        /* Update storage */
        s = ({...s, account_info: Big_map.update(params.from_, Some(src_account), s.account_info)});

        /* Create or get destination account */
        let dst_account: account_t = get_account(transfer_dst.to_, s);

        /* Get receiver balance */
        const dst_balance: nat = get_balance_by_token(dst_account, transfer_dst.token_id);

        /* Update destination balance */
        dst_account = ({
            ...dst_account,
            balances: Map.update(transfer_dst.token_id, Some(dst_balance + transfer_dst.amount), dst_account.balances)
        });

        /* Update storage */
        s = ({...s, account_info: Big_map.update(transfer_dst.to_, Some(dst_account), s.account_info)});

        return s;
    };

    return List.fold(make_transfer, params.txs, s);
};

/* Perform single operator update */
const iterate_update_operators = ([s_, params]: [storage_t, update_operator_param_t]): storage_t => {
    let s = s_;
    match(params) {
        when(Add_operator(param)): do {
            /* Check an owner */
            assert_with_error(Tezos.get_sender() == param.owner, not_owner);

            /* Create or get source account */
            let src_account: account_t = get_account(param.owner, s);

            /* Add operator */
            src_account = ({...src_account, permits: Set.add(param.operator, src_account.permits)});

            /* Update storage */
            s = ({...s, account_info: Big_map.update(param.owner, Some(src_account), s.account_info)});
        };
        when(Remove_operator(param)): do {
            /* Check an owner */
            assert_with_error(Tezos.get_sender() == param.owner, not_owner);

            /* Create or get source account */
            let src_account: account_t = get_account(param.owner, s);

            /* Remove operator */
            src_account = ({...src_account, permits: Set.remove(param.operator, src_account.permits)});

            /* Update storage */
            s = ({...s, account_info: Big_map.update(param.owner, Some(src_account), s.account_info)});
        }
    };

    return s;
};

/* Perform balance lookup */
const get_balance_of = (balance_params: balance_params_t, s: storage_t): list<operation> => {
    /* Perform single balance lookup */
    const look_up_balance = ([l, request]: [list<balance_of_response_t>, balance_of_request_t]): list<balance_of_response_t> => {
        /* Retrieve the asked account from the storage */
        const user: account_t = get_account(request.owner, s);

        /* Form the response */
        let response: balance_of_response_t = {
          request: request,
          balance: get_balance_by_token(user, request.token_id)
        };

        return list([response, ...l]);
    };

    /* Collect balances info */
    const accumulated_response: list<balance_of_response_t> = List.fold(look_up_balance, balance_params.requests, (list([]) as list<balance_of_response_t>));
    
    return list([Tezos.Next.Operation.transaction(accumulated_response, (0 as tez), balance_params.callback)]);
};

const update_operators = (s: storage_t, params: update_operator_params_t): storage_t =>
  List.fold(iterate_update_operators, params, s);

const transfer = (s: storage_t, params: transfer_params_t): storage_t =>
  List.fold(iterate_transfer, params, s);

/* Perform minting new tokens */
const mint_asset = (
    params: asset_params_t,
    s: storage_t
): storage_t => {
    const make_mint = ([s_, param]: [storage_t, asset_param_t]): storage_t => {
        let s = s_;
        assert_with_error(param.token_id < s.last_token_id, undefined);

        /* Get receiver account */
        let dst_account: account_t = get_account(param.receiver, s);

        /* Get receiver initial balance */
        const dst_balance: nat = get_balance_by_token(dst_account, param.token_id);

        /* Mint new tokens */
        dst_account = ({
            ...dst_account,
            balances: Map.update(param.token_id, Some(dst_balance + param.amount), dst_account.balances)
        });

        /* Get token info */
        let token: token_info_t = get_token_info(param.token_id, s);

        /* Update token total supply */
        token = ({...token, total_supply: token.total_supply + param.amount});

        /* Update storage */
        s = ({
            ...s, 
            account_info: Big_map.update(param.receiver, Some(dst_account), s.account_info),
            token_info: Big_map.update(param.token_id, Some(token), s.token_info)
        });

        return s;
    };

    return List.fold(make_mint, params, s);
};

const create_token = (
  create_params: new_token_params_t,
  s_: storage_t
): storage_t => {
    let s = s_;
    assert_with_error(s.admin == Tezos.get_sender(), not_admin);

    s = ({
        ...s,
        token_metadata: Big_map.update(
            s.last_token_id, 
            Some({token_id: s.last_token_id, token_info: create_params}),
            s.token_metadata
        ),
        last_token_id: s.last_token_id + (1 as nat)
    });

    return s;
};

const update_metadata = (
    params: update_meta_param_t,
    s_: storage_t
): storage_t => {
    let s = s_;
    assert_with_error(s.admin == Tezos.get_sender(), not_admin);

    s = ({...s, token_metadata: Big_map.update(params.token_id, Some(params), s.token_metadata)});

    return s;
};

@entry
const main = (
    action: action_t,
    s: storage_t
): [list<operation>, storage_t] => match(action) {
    when(Create_token(params)): [no_operations, create_token(params, s)];
    when(Mint_asset(params)): [no_operations, mint_asset(params, s)];
    when(Transfer(params)): [no_operations, transfer(s, params)];
    when(Update_operators(params)): [no_operations, update_operators(s, params)];
    when(Balance_of(params)): [get_balance_of(params, s), s];
    when(Update_metadata(params)): [no_operations, update_metadata(params, s)]
};
